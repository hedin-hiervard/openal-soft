package com.palmkingdoms.pk2_remastered

import android.app.Activity
import android.content.Context
import android.opengl.GLSurfaceView
import android.os.Bundle
import android.util.Log
import java.nio.IntBuffer
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.nio.FloatBuffer
import javax.microedition.khronos.egl.*
import javax.microedition.khronos.opengles.GL10
import javax.microedition.khronos.opengles.GL10.*

class MainActivity : Activity() {


    inner class MyGLRenderer : GLSurfaceView.Renderer {
        lateinit var textureBuffer: ByteBuffer

        private var screenTexture: Int = 0
        private var textureWidth: Int = 0
        private var textureHeight: Int = 0
        private var screenWidth: Int = 0
        private var screenHeight: Int = 0
        private var viewRenderbuffer: Int = 0
	    private var viewFramebuffer: Int = 0

        private fun getSizeNextPOT(size: Int): Int {
            var log: Double = 0.0
            while(Math.pow(2.0, log) < size) { log++ }
            return Math.pow(2.0, log).toInt()
        }

        override fun onSurfaceCreated(gl: GL10?, config: EGLConfig?) {
            gl?.glClearColor(1.0f, 0.0f, 0.0f, 1.0f)
        }

        override fun onSurfaceChanged(gl: GL10, width: Int, height: Int) {
            screenWidth = width
            screenHeight = height

            gl?.glViewport(0, 0, screenWidth, screenHeight)

            gl?.glMatrixMode(GL_PROJECTION)
            gl?.glLoadIdentity();
//
            gl?.glRotatef(180.0f, 0.0f, 0.0f, 1.0f)
            gl?.glOrthof(0f, width.toFloat(), 0.0f, height.toFloat(), 0.0f, 1.0f)

//            textureWidth = getSizeNextPOT(screenWidth)
//            textureHeight = getSizeNextPOT(screenHeight)
            textureWidth = 128
            textureHeight = 128

            textureBuffer = ByteBuffer.allocateDirect(textureHeight * textureWidth * 8)
            for(i in 0 .. textureHeight * textureWidth * 8 - 1) {
                textureBuffer.put(64.toByte())
            }

            Log.i("PK2", "texture size: %d x %d".format(textureWidth, textureHeight))

            val textures = IntBuffer.allocate(1)
            gl?.glGenTextures(1, textures)
            screenTexture = textures[0]

            gl?.glEnable(GL_TEXTURE_2D)

//            val b1 = IntBuffer.allocate(1)
//            glGenFramebuffers(1, b1)
//            viewFramebuffer = b1[0]
//            val b2 = IntBuffer.allocate(1)
//
//            glGenRenderbuffers(1, b2)
//            viewRenderbuffer = b2[0]
//
//            glBindFramebuffer(GL_FRAMEBUFFER, viewFramebuffer)
//            glBindRenderbuffer(GL_RENDERBUFFER, viewRenderbuffer)


            gl?.glEnableClientState(GL_TEXTURE_COORD_ARRAY);
            gl?.glEnableClientState(GL_VERTEX_ARRAY);
            gl?.glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
            gl?.glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
            gl?.glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT)
            gl?.glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT)

//            gl?.glDisable(GL_BLEND)
            native_onSurfaceCreated(screenWidth, screenHeight)
        }

        override fun onDrawFrame(gl: GL10) {
            // Redraw background color
            gl.glClear(GL_COLOR_BUFFER_BIT)

            gl.glMatrixMode(GL_MODELVIEW)
            gl.glLoadIdentity()   // reset the matrix to its default state

            val widthOffset = screenWidth
            val heightOffset = screenHeight

            val visibleWidth = screenWidth
            val visibleHeight = screenHeight

            val texWidth = visibleWidth / textureWidth
            val texHeight = visibleHeight / textureHeight

            val vertices = floatArrayOf(
                0.0f,
                0.0f + widthOffset,
                visibleWidth.toFloat(),
                0.0f + widthOffset,
                0.0f,
                visibleHeight.toFloat() - widthOffset.toFloat(),
                visibleWidth.toFloat(),
                visibleHeight.toFloat() - widthOffset.toFloat()
            )
            val byteBuffer = ByteBuffer.allocateDirect(vertices.size * 4)
            byteBuffer.order(ByteOrder.nativeOrder())
            val vertexBuffer: FloatBuffer
            vertexBuffer = byteBuffer.asFloatBuffer()
            vertexBuffer.put(vertices)
            vertexBuffer.position(0)

            gl.glVertexPointer(2, GL_FLOAT, 0, vertexBuffer)

            val texCoords = floatArrayOf(
                texWidth.toFloat(),
                0.0f,
                0.0f,
                0.0f,
                texWidth.toFloat(),
                texHeight.toFloat(),
                0.0f,
                texHeight.toFloat()
            )
            val byteBuffer2 = ByteBuffer.allocateDirect(texCoords.size * 4)
            byteBuffer2.order(ByteOrder.nativeOrder())
            val texBuffer: FloatBuffer
            texBuffer = byteBuffer2.asFloatBuffer()
            texBuffer.put(vertices)
            texBuffer.position(0)

            gl.glTexCoordPointer(2, GL_FLOAT, 0, texBuffer)
            gl.glBindTexture(GL_TEXTURE_2D, screenTexture)
            gl.glTexImage2D(
                GL_TEXTURE_2D,
                0,
                GL_RGB,
                textureWidth,
                textureHeight,
                0,
                GL_RGB,
                GL_UNSIGNED_SHORT_5_6_5,
                textureBuffer
            )

            gl.glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
//            glBindRenderbufferOES(GL_RENDERBUFFER_OES, _viewRenderbuffer);
//            [_context presentRenderbuffer:GL_RENDERBUFFER_OES];
        }
    }

    inner class MyGLSurfaceView(context: Context) : GLSurfaceView(context) {

        private val renderer: MyGLRenderer

        init {

            // Create an OpenGL ES 2.0 context
            setEGLContextClientVersion(2)

            renderer = MyGLRenderer()

            // Set the Renderer for drawing on the GLSurfaceView
            setRenderer(renderer)

            renderMode = GLSurfaceView.RENDERMODE_CONTINUOUSLY
        }
    }

    private lateinit var gLView: GLSurfaceView

    public override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        native_onStart()

        // Create a GLSurfaceView instance and set it
        // as the ContentView for this Activity.
        gLView = MyGLSurfaceView(this)
        setContentView(gLView)

    }

    private fun updateSurface(data: ByteArray) {
        textureBuffer.position(0)
        textureBuffer.put(data)
    }

    private fun log(text: String) {
        Log.i("PK2", text)
    }

    external fun native_onMouseDown(x: Int, y: Int, mID: Int, mbID: Int)
    external fun native_onMouseUp(x: Int, y: Int, mID: Int, mbID: Int)
    external fun native_onMouseMove(x: Int, y: Int, mID: Int, mbID: Int)
    external fun native_onSurfaceCreated(width: Int, height: Int)
    external fun native_onStart()
    external fun native_onQuit()

    companion object {

        // Used to load the 'native-lib' library on application startup.
        init {
            System.loadLibrary("native-lib")
        }
    }
}
